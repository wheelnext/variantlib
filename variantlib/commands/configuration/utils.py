from __future__ import annotations

import curses
import os
import pathlib
import sys
import time

import tomli_w
import tomllib


def read_toml_file(
    filepath: pathlib.Path,
) -> tuple[dict[str, list[str]], dict[str, str]]:
    assert isinstance(filepath, pathlib.Path), (
        f"Path must be a pathlib.Path object, received: {type(filepath)}"
    )
    # File must be opened in binary mode for tomllib
    with filepath.open(mode="rb") as file:
        content = file.read()
        comments = {}
        lines = content.decode("utf-8").splitlines()
        current_comments = []

        # Remove the first lines of the example `variants.toml` file
        if "EXAMPLE `variants.toml` FILE" in lines[0]:
            lines = lines[1:]
        if lines[0].strip() == "":
            lines = lines[1:]

        for line in lines:
            if line.strip() and not line.strip().startswith("#"):
                if "=" in line or ("[" in line and "]" in line):
                    key = (
                        line.split("=")[0].strip()
                        if "=" in line
                        else line.strip()[1:-1]
                    )
                    comments[key] = current_comments
                    current_comments = []
            else:
                current_comments.append(line.strip())

        file.seek(0)  # Reset file pointer to the beginning
        data = tomllib.load(file)

        return comments, data


def write_toml_file(
    filepath: pathlib.Path, comments: dict[str, list[str]], data: dict[str, str]
):
    with filepath.open(mode="wb") as file:
        file.write(
            f"{'#' * 10} "
            "This file has been auto-generated by VariantLib on "
            f"{time.strftime('%Y-%m-%d %H:%M', time.localtime())} "
            f"{'#' * 10}\n\n".encode()
        )
        for key, value in data.items():
            if comments.get(key):
                file.writelines(
                    [f"{line.strip()}\n".encode() for line in comments[key]]
                )
            tomli_w.dump({key: value}, file)


def clear_console():
    sys.stdout.write("\033[2J\033[H") if os.name != "nt" else sys.stdout.write(
        "\033[2J"
    )
    sys.stdout.flush()


def user_confirmation_prompt(message: str, default_is_true: bool) -> bool:
    """Prompt the user for confirmation with a message."""
    response = input(f"{message} {'[Y/n]' if default_is_true else '[y/N]'}: ").lower()
    if default_is_true:
        return response != "n"

    return response == "y"


def _get_user_preferences(
    stdscr, instructions: str, user_options: list[str], is_optional: bool
) -> list[str]:
    ordered_options = []

    # Clear screen
    stdscr.clear()

    def get_user_choice(options):
        current_row = 0

        while True:
            stdscr.clear()
            # instructions = dedent("""\
            #     Feature priorities
            #     ==================

            #     Please select the following variant feature, in preference order,
            #     that you wish to prioritze above everything else. When you are done
            #     select EXIT.\n""")
            stdscr.addstr(0, 0, instructions)

            line_offset = len(instructions.splitlines()) + 1
            for idx, feature in enumerate(options):
                if idx == current_row:
                    stdscr.addstr(
                        idx + line_offset, 0, f"> {feature}", curses.A_REVERSE
                    )
                else:
                    stdscr.addstr(idx + line_offset, 0, f"  {feature}")
            stdscr.refresh()

            key = stdscr.getch()
            if key == curses.KEY_UP and current_row > 0:
                current_row -= 1
            elif key == curses.KEY_DOWN and current_row < len(options) - 1:
                current_row += 1
            elif key == curses.KEY_ENTER or key in [10, 13]:
                return current_row

    if is_optional:
        user_options += ["EXIT"]

    while user_options:
        choice_index = get_user_choice(user_options)
        if is_optional and choice_index == len(user_options) - 1:
            break
        ordered_options.append(user_options.pop(choice_index))

    stdscr.clear()

    return ordered_options


def get_user_preferences(
    setting_name: str, instructions: str, user_options: list[str], is_optional: bool
) -> list[str]:
    """Get user preferences from the command line interface."""
    # Maximum 5 attempts for the user before exiting to avoid infinite loops.
    for _ in range(5):
        data = curses.wrapper(
            _get_user_preferences, instructions, user_options, is_optional=is_optional
        )
        clear_console()
        sys.stdout.write(f"You elected to choose the following {setting_name}:\n\n")
        for idx, feature in enumerate(data, 1):
            sys.stdout.write(f"{idx}. {feature}\n")
        sys.stdout.write("\n")

        if user_confirmation_prompt(
            "Are you satisfied with the given order", default_is_true=True
        ):
            break
    else:
        raise RuntimeError(f"User was not able to select any {setting_name}.")
    return data
